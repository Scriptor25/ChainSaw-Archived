## Constants

num infinity = inf();
num pi = 3.1415926535897932385;

## Utility Functions

degrees_to_radians: num << [degrees: num] {
    ret degrees * pi / 180;
}

## Things

thing: vec3;
thing: ray;
thing: hit_record;
thing: sphere;
thing: hittable_list;

ray_color: vec3 << [r: ray, world: hittable_list] {
    hit_record rec;
    if (world.hit(r, 0, infinity, rec))
        ret mul(0.5, add(rec.normal, vec3(1, 1, 1)));
    
    vec3 unit_direction = unit_vector(r.dir);
    num a = 0.5 * (unit_direction.y + 1.0);
    ret add(mul(1.0 - a, vec3(1.0, 1.0, 1.0)), mul(a, vec3(0.5, 0.7, 1.0)));
}

main: num {

    ## Image

    num aspect_ratio = 16 / 9;
    num image_width = 256;

    ## Calculate the image height, and ensure it's at least 1.
    num image_height = floor(image_width / aspect_ratio);
    image_height = (image_height < 1) ? 1 : image_height;

    ## World

    hittable_list world = hittable_list();

    world.add(sphere(vec3(0, 0, -1), 0.5));
    world.add(sphere(vec3(0, -100.5, -1), 100));

    ## Camera

    num focal_length = 1.0;
    num viewport_height = 2.0;
    num viewport_width = viewport_height * (image_width / image_height);
    vec3 camera_center = vec3(0, 0, 0);

    ## Calculate the vectors across the horizontal and down the vertical viewport edges.
    vec3 viewport_u = vec3(viewport_width, 0, 0);
    vec3 viewport_v = vec3(0, -viewport_height, 0);

    ## Calculate the horizontal and vertical delta vectors from pixel to pixel.
    vec3 pixel_delta_u = div(viewport_u, image_width);
    vec3 pixel_delta_v = div(viewport_v, image_height);

    ## Calculate the location of the upper left pixel.
    vec3 viewport_upper_left = sub(sub(sub(camera_center, vec3(0, 0, focal_length)), div(viewport_u, 2)), div(viewport_v, 2));
    vec3 pixel00_loc = add(viewport_upper_left, mul(0.5, add(pixel_delta_u, pixel_delta_v)));

    ## Render

    file f = file("output.ppm", "out");
    f.out("P3\n%s %s\n255\n", image_width, image_height);

    for (num j = 0; j < image_height; j++) {
        out("\rScanlines remaining: %s ", image_height - j);
        for (num i = 0; i < image_width; i++) {
            vec3 pixel_center = add(add(pixel00_loc, mul(i, pixel_delta_u)), mul(j, pixel_delta_v));
            vec3 ray_direction = sub(pixel_center, camera_center);
            ray r = ray(camera_center, ray_direction);

            vec3 pixel_color = ray_color(r, world);
            write_color(f, pixel_color);
        }
    }

    out("\rDone.                 \n");

    f.close();

    ret 0;
}

## VEC3

thing: vec3 {
    x: num,
    y: num,
    z: num,
}

$vec3 {
    my = vec3(0, 0, 0);
}

$vec3 << [x: num, y: num, z: num] {
    my.x = x;
    my.y = y;
    my.z = z;
}

neg: vec3 -> vec3 {
    ret vec3(-my.x, -my.y, -my.z);
}

e: num << [i: num] -> vec3 {
    switch (i) {
        case 0: ret my.x;
        case 1: ret my.y;
        case 2: ret my.z;
        default: ret 0;
    }
}

add: vec3 << [v: vec3] -> vec3 {
    my.x += v.x;
    my.y += v.y;
    my.z += v.z;
    ret my;
}

mul: vec3 << [t: num] -> vec3 {
    my.x *= t;
    my.y *= t;
    my.z *= t;
    ret my;
}

div: vec3 << [t: num] -> vec3 {
    ret my.mul(1 / t);
}

length: num -> vec3 {
    ret sqrt(my.length_squared());
}

length_squared: num -> vec3 {
    ret my.x * my.x + my.y * my.y + my.z * my.z;
}

out << [v: vec3] {
    my.out("%s %s %s", v.x, v.y, v.z);
}

add: vec3 << [u: vec3, v: vec3] {
    ret vec3(u.x + v.x, u.y + v.y, u.z + v.z);
}

sub: vec3 << [u: vec3, v: vec3] {
    ret vec3(u.x - v.x, u.y - v.y, u.z - v.z);
}

mul: vec3 << [u: vec3, v: vec3] {
    ret vec3(u.x * v.x, u.y * v.y, u.z * v.z);
}

mul: vec3 << [t: num, v: vec3] {
    ret vec3(t * v.x, t * v.y, t * v.z);
}

mul: vec3 << [v: vec3, t: num] {
    ret mul(t, v);
}

div: vec3 << [v: vec3, t: num] {
    ret mul(1 / t, v);
}

dot: num << [u: vec3, v: vec3] {
    ret u.x * v.x + u.y * v.y + u.z * v.z;
}

cross: vec3 << [u: vec3, v: vec3] {
    ret vec3(
        u.y * v.z - u.z * v.y,
        u.z * v.x - u.x * v.z,
        u.x * v.y - u.y * v.x
    );
}

unit_vector: vec3 << [v: vec3] {
    ret div(v, v.length());
}

write_color << [f: file, pixel_color: vec3] {
    f.out(
        "%s %s %s\n", 
        floor(255.999 * pixel_color.x),
        floor(255.999 * pixel_color.y),
        floor(255.999 * pixel_color.z)
    );
}

thing: ray {
    orig: vec3,
    dir: vec3,
}

$ray {}

$ray << [origin: vec3, direction: vec3] {
    my.orig = origin;
    my.dir = direction;
}

at: vec3 << [t: num] -> ray {
    ret add(my.orig, mul(t, my.dir));
}

thing: hit_record {
    p: vec3,
    normal: vec3,
    t: num,
    front_face: num,
}

set_face_normal << [r: ray, outward_normal: vec3] -> hit_record {
    ## Sets the hit record normal vector.
    ## NOTE: the parameter `outward_normal` is assumed to have unit length.

    my.front_face = dot(r.dir, outward_normal) < 0;
    my.normal = my.front_face ? outward_normal : outward_normal.neg();
}

set << [rec: hit_record] -> hit_record {
    my.p = rec.p;
    my.normal = rec.normal;
    my.t = rec.t;
    my.front_face = rec.front_face;
}

thing: sphere {
    center: vec3,
    radius: num,
}

$sphere << [cen: vec3, rad: num] {
    my.center = cen;
    my.radius = rad;
}

hit: num << [r: ray, ray_tmin: num, ray_tmax: num, rec: hit_record] -> sphere {
    vec3 oc = sub(r.orig, my.center);
    num a = r.dir.length_squared();
    num half_b = dot(oc, r.dir);
    num c = oc.length_squared() - my.radius * my.radius;

    num discriminant = half_b * half_b - a * c;
    if (discriminant < 0) ret 0;
    num sqrtd = sqrt(discriminant);

    ## Find the nearest root that lies in the acceptable range.
    num root = (-half_b - sqrtd) / a;
    if (root <= ray_tmin || ray_tmax <= root) {
        root = (-half_b + sqrtd) / a;
        if (root <= ray_tmin || ray_tmax <= root)
            ret 0;
    }

    rec.t = root;
    rec.p = r.at(rec.t);
    vec3 outward_normal = div(sub(rec.p, my.center), my.radius);
    rec.set_face_normal(r, outward_normal);

    ret 1;
}

thing: hittable_list {
    objects: list,
}

$hittable_list {
    my.objects = list();
}

$hittable_list << [object: void] {
    my.objects = list();
    my.objects.add(object);
}

clear -> hittable_list {
    my.objects.clear();
}

add << [object: void] -> hittable_list {
    my.objects.add(object);
}

hit: num << [r: ray, ray_tmin: num, ray_tmax: num, rec: hit_record] -> hittable_list {
    hit_record temp_rec;
    num hit_anything = 0;
    num closest_so_far = ray_tmax;

    for (num i = 0; i < my.objects.size(); i++) {
        sphere object = my.objects.get(i);
        if (object.hit(r, ray_tmin, closest_so_far, temp_rec)) {
            hit_anything = 1;
            closest_so_far = temp_rec.t;
            rec.set(temp_rec);
        }
    }

    ret hit_anything;
}
