number pi = 3.1415926535897932385;

thing: vec3;
thing: ray;

write_color [f: file, pixel_color: vec3] {
    f.out(
        "%s %s %s%n",
        floor(255.999 * pixel_color.x),
        floor(255.999 * pixel_color.y),
        floor(255.999 * pixel_color.z)
    );
}

hit_sphere: number [center: vec3, radius: number, r: ray] {
    vec3 oc = r.origin() - center;
    number a = (r.direction()).length_squared();
    number half_b = dot(oc, r.direction());
    number c = oc.length_squared() - radius * radius;
    number discriminant = half_b * half_b - a * c;
    
    if (discriminant < 0) {
        ret -1.0;
    } else {
        ret (-half_b - sqrt(discriminant)) / a;
    }
}

ray_color: vec3 [r: ray] {
    number t = hit_sphere(vec3(0, 0, -1), 0.5, r);
    if (t > 0.0) {
        vec3 N = unit_vector(r.at(t) - vec3(0, 0, -1));
        ret N * 0.5 + 0.5;
    }

    vec3 unit_direction = unit_vector(r.direction());
    number a = 0.5 * (unit_direction.y() + 1.0);
    ret (1.0 - a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
}

main: number {

    ## Image

    number aspect_ratio = 16 / 9;
    number image_width = 400;

    ## Calculate the image height, and ensure that it's at least 1.
    number image_height = floor(image_width / aspect_ratio);
    image_height = (image_height < 1) ? 1 : image_height;

    ## Camera

    number focal_length = 1;
    number viewport_height = 2;
    number viewport_width = viewport_height * (image_width / image_height);
    vec3 camera_center = vec3(0, 0, 0);

    ## Calculate the vectors across the horizontal and down the vertical viewport edges.
    vec3 viewport_u = vec3(viewport_width, 0, 0);
    vec3 viewport_v = vec3(0, -viewport_height, 0);

    ## Calculate the horizontal and vertical delta vectors from pixel to pixel.
    vec3 pixel_delta_u = viewport_u / image_width;
    vec3 pixel_delta_v = viewport_v / image_height;

    ## Calculate the location of the upper left pixel.
    vec3 viewport_upper_left = camera_center - vec3(0, 0, focal_length) - viewport_u / 2 - viewport_v / 2;
    vec3 pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);

    ## Render

    file f = file("output.ppm", "out");
    f.out("P3%n%s %s\n255%n", image_width, image_height);

    for (number j = 0; j < image_height; j++) {
        out("\rScanlines remaining: %s ", image_height - j);
        for (number i = 0; i < image_width; i++) {
            vec3 pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);
            vec3 ray_direction = pixel_center - camera_center;
            ray r = ray(camera_center, ray_direction);

            vec3 pixel_color = ray_color(r);
            write_color(f, pixel_color);
        }
    }

    out("\rDone.                       %n");

    f.close();

    ret 0;
}

thing: vec3 {
    x: number,
    y: number,
    z: number
}

$vec3 {
    my.x = my.y = my.z = 0;
}

$vec3 [x: number, y: number, z: number] {
    my.x = x; my.y = y; my.z = z;
}

x: number -> vec3 { ret my.x; }
y: number -> vec3 { ret my.y; }
z: number -> vec3 { ret my.z; }

(-): vec3 -> vec3 {
    ret vec3(-my.x, -my.y, -my.z);
}

e: number [i: number] -> vec3 {
    switch (i) {
        case 0: ret my.x;
        case 1: ret my.y;
        case 2: ret my.z;
        default: ret 0;
    }
}

(+): vec3 [v: vec3] -> vec3 {
    my.x += v.x;
    my.y += v.y;
    my.z += v.z;
    ret my;
}

(*): vec3 [t: number] -> vec3 {
    my.x *= t;
    my.y *= t;
    my.z *= t;
    ret my;
}

(/): vec3 [t: number] -> vec3 {
    ret my *= 1 / t;
}

length: number -> vec3 {
    ret sqrt(my.length_squared());
}

length_squared: number -> vec3 {
    ret my.x * my.x + my.y * my.y + my.z * my.z;
}

## Vector Utility Functions

out [v: vec3] {
    out("[ %s %s %s ]", v.x, v.y, v.z);
}

(+): vec3 [u: vec3, v: vec3] {
    ret vec3(u.x + v.x, u.y + v.y, u.z + v.z);
}

(+): vec3 [t: number, v: vec3] {
    ret vec3(t + v.x, t + v.y, t + v.z);
}

(+): vec3 [v: vec3, t: number] {
    ret t + v;
}

(-): vec3 [u: vec3, v: vec3] {
    ret vec3(u.x - v.x, u.y - v.y, u.z - v.z);
}

(*): vec3 [u: vec3, v: vec3] {
    ret vec3(u.x * v.x, u.y * v.y, u.z * v.z);
}

(*): vec3 [t: number, v: vec3] {
    ret vec3(t * v.x, t * v.y, t * v.z);
}

(*): vec3 [v: vec3, t: number] {
    ret t * v;
}

(/): vec3 [v: vec3, t: number] {
    ret (1 / t) * v;
}

dot: number [u: vec3, v: vec3] {
    ret u.x * v.x + u.y * v.y + u.z * v.z;
}

cross: vec3 [u: vec3, v: vec3] {
    ret vec3(
        u.y * v.z - u.z * v.y,
        u.z * v.x - u.x * v.z,
        u.x * v.y - u.y * v.x
    );
}

unit_vector: vec3 [v: vec3] {
    ret v / v.length();
}

thing: ray {
    orig: vec3,
    dir: vec3
}

$ray { my.orig = my.dir = vec3(); }
$ray [origin: vec3, direction: vec3] {
    my.orig = origin;
    my.dir = direction;
}

origin: vec3 -> ray { ret my.orig; }
direction: vec3 -> ray { ret my.dir; }

at: vec3 [t: number] -> ray { ret my.orig + t * my.dir; }

get_sphere_uv: vec3 [p: vec3] {

    ## p: a given point on the sphere of radius one, centered at the origin.
    ## u: returned value [0,1] of angle around the Y axis from X=-1.
    ## v: returned value [0,1] of angle from Y=-1 to Y=+1.
    ##     <1 0 0> yields <0.50 0.50>       <-1  0  0> yields <0.00 0.50>
    ##     <0 1 0> yields <0.50 1.00>       < 0 -1  0> yields <0.50 0.00>
    ##     <0 0 1> yields <0.25 0.50>       < 0  0 -1> yields <0.75 0.50>

    number theta = acos(-p.y());
    number phi = atan2(-p.z(), p.x()) + pi;

    vec3 uv;
    uv.x = phi / (2 * pi);
    uv.y = theta / pi;

    ret uv;
}
