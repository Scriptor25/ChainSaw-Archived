thing: string;

## define a function:
## this one is only the definition, and it has a variable amount of args at the end
out << [msg: string] var;

## define a thing (struct)
thing: test {
    a: float,
    b: int,
}

thing: membered {
    t: test,
    f: float
}

## a function with body:
## this one has no return type and does not have any args
helloWorld {
    out("Hello, World!%n");
}

## this function takes an int named n and returns an int
fib: int << [n: int] {
    if (n == 0) ret 0;
    if (n == 1) ret 1;
    ret fib(n - 1) + fib(n - 2);
}

## this function is used as a constructor for a test-thing, taking in a float a and an int b, returning a instance of test
test: test << [a: float, b: int] {
    test this;
    this.a = a;
    this.b = b;
    ret this;
}

membered: membered << [t: test, f: float] {
    membered this;
    this.t = t;
    this.f = f;
    ret this;
}

## the main entry function always returns an int
main: int {
    helloWorld();
    out("fib(10) = %d%n", fib(10));
    out("%d * %d = %d%n", 5, 10, 5 * 10);

    test t = test(0.1, 2);
    membered m = membered(t, 6.9);

    out("%f%n", m.t.a + m.t.b * m.f);

    ret 0;
}

## primitives:
## - int
## - float

## constant values:
## - number     (e.g. 0.1, 20, 6.9, ...)
## - string     (e.g. "helloooo")
## - character  (e.g. 'a')

## functions: (? means optional, ! means required)
## <!name: identifier>: <?type: identifier> << [[?params: <!name: identifier>: <!type: identifier>, ...]] <?var> {}

## things:
## thing: <!name: identifier> { [?fields: <!name: identifier>: <!type: identifier>, ...] };